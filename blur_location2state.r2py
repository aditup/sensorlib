"""
A security layer for the functions get_location() and get_lastknown_location()
defined in getsensor.r2py. This program blurs the latitude/longitude
coordinates, received from the location sensors of an Android device,
to the geographic center of approximately the nearest state (admin division).

The blurring is done using a database lookup method. First, we use the
get_geolocation() call to get the current address. The country code 
("country_code") in the address returned is then used to look up the 
list of states for that country from the database. This database,
located at http://sensibilityclearinghouse.poly.edu/data/states/, is a 
list of all states/admin divisions and their corresponding geodata
(state code, latitude, longitude) divided by country, where each file
is named with the 2-letter country code (e.g., "US.txt").

Next, we use the state name ("admin_area") from the returned address to
check for a match with the list of states. If there is a match, the
coordinates associated with that state are returned. If there is no
match, we look for the state that has coordinates closest to the
those received from the location sensors of the Android device
and return its latitude and longitude.

Usage:
  start dylink.r2py encasementlib.r2py sensor_layer.r2py \
    blur_location2state.r2py user-program.r2py
"""



blur_helper = dy_import_module("blur_helper.r2py")



def load_state_geodata(filename, address):
  """
  Loads the state(s) and the corresponding latitude and longitude from
  the given file into a dictionary.
  
  Below is an example of a line from the given file (state code, state
  name, latitude, longitude):
  US.NY    New York    43.00035    -75.4999
  
  The dictionary that is returned has
  the format:
  {
    state1: {"latitude": latitude, "longitude": longitude},
    state2: {"latitude": latitude, "longitude": longitude},
    ...
  }

  """
  states_dict = {}
  states_geodata_fileobj = openfile(filename.lower(), False)
  states_geodata_file = states_geodata_fileobj.readat(None, 0).split("\n")
  states_geodata_fileobj.close()

  # Check if we can match the state name in the given address to the
  # name in the database. If there is a match, return a dict with that
  # state and its geodata.
  if "admin_area" in address:
    for line in states_geodata_file:
      # Ignore the empty line at the end of the file.
      if line == "":
        continue
      state_geodata_record = line.split("\t")
      if address["admin_area"] == state_geodata_record[1]:
        states_dict[address["admin_area"]] = {
          "latitude": float(state_geodata_record[2]),
          "longitude": float(state_geodata_record[3]),
        }
        return states_dict

  # If no match, return a dict of all states and their geodata to
  # find the closest state.
  for line in states_geodata_file:
    # Ignore the empty line at the end of the file.
    if line == "":
      continue
    state_geodata_record = line.split("\t")
    state_name = state_geodata_record[1]
    states_dict[state_name] = {
      "latitude": float(state_geodata_record[2]),
      "longitude": float(state_geodata_record[3]),
    }

  return states_dict



def find_closest_state(lat, lon):
  """
  Finds the state closest to the given latitude/longitude pair from the
  dictionary of states returned by the load_state_geodata() function,
  and returns its name, latitude and longitude in a dictionary. If the
  load_state_geodata() function returns only one state, then that
  state's name along with its latitude and longitude is returned in the
  dictionary.
  The dictionary returned has the format:
  {
    "state_name": state name (string),
    "latitude": latitude of the geographic center of the state (float)
    "longitude": longitude of the geographic center of the state (float)
  }

  """
  # Get the address for the given coordinates.
  address = get_geolocation(lat, lon, 1)[0]

  # Use the country code to get the filename of the list of states
  # for that country.
  filename = address["country_code"] + ".txt"

  # Download the file from the server.
  blur_helper.get_file_from_server(filename, 2)

  # Load the state(s) and corresponding geodata from the file.
  states_dict = load_state_geodata(filename, address)

  return blur_helper.find_closest_blur_level(lat, lon, states_dict)



def get_state_location():
  """
  Blurring layer for the get_location() function. It replaces the exact
  coordinates of the Android device with the coordinates for the
  geographic center of the nearest state.

  """
  location_data = get_location()

  closest_state = find_closest_state(location_data["latitude"],
    location_data["longitude"])

  location_data["latitude"] = closest_state["latitude"]
  location_data["longitude"] = closest_state["longitude"]

  return location_data



def get_state_lastknown_location():
  """
  Blurring layer for the get_lastknown_location() function. It replaces
  the last-known coordinates of the Android device with the coordinates
  for the geographic center of the nearest state.

  """
  location_data = get_lastknown_location()

  # Get the location from every provider
  for location_provider, provider_location_data in location_data.items():
    # Skip blurring this provider's data if it doesn't contain a previous
    # location.
    if provider_location_data is None:
      continue

    closest_state = find_closest_state(provider_location_data["latitude"],
      provider_location_data["longitude"])
    
    location_data[location_provider]["latitude"] = closest_state["latitude"]
    location_data[location_provider]["longitude"] = closest_state["longitude"]

  return location_data



# Mapping our blurring function get_state_location to get_location.
CHILD_CONTEXT_DEF["get_location"] = {
    "type": "func",
    "args": None,
    "return": dict,
    "exceptions": "any",
    "target": get_state_location,
}


# Mapping our blurring function get_state_lastknown_location to
# get_lastknown_location.
CHILD_CONTEXT_DEF["get_lastknown_location"] = {
    "type": "func",
    "args": None,
    "return": dict,
    "exceptions": "any",
    "target": get_state_lastknown_location,
}


# Dispatch
secure_dispatch_module()